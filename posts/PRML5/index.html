<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="PRML-5" /><meta property="og:locale" content="en" /><meta name="description" content="5. Neural Networks" /><meta property="og:description" content="5. Neural Networks" /><link rel="canonical" href="https://hwankam.github.io/posts/PRML5/" /><meta property="og:url" content="https://hwankam.github.io/posts/PRML5/" /><meta property="og:site_name" content="For Statistics" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-09T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="PRML-5" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"5. Neural Networks","url":"https://hwankam.github.io/posts/PRML5/","headline":"PRML-5","dateModified":"2022-03-01T22:43:39+09:00","datePublished":"2022-02-09T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://hwankam.github.io/posts/PRML5/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>PRML-5 | For Statistics</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="For Statistics"><meta name="application-name" content="For Statistics"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">For Statistics</a></div><div class="site-subtitle font-italic">kam's world</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/Hwankam" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>PRML-5</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>PRML-5</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> your_full_name </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 9, 2022, 12:00 AM +0900" >Feb 9<i class="unloaded">2022-02-09T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Mar 1, 2022, 10:43 PM +0900" >Mar 1<i class="unloaded">2022-03-01T22:43:39+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4754 words">26 min read</span></div></div><div class="post-content"><h2 id="5-neural-networks">5. Neural Networks</h2><p>chap 3과 4에서는 linear combination of fixed bases function에 대해 배웠다. 그러나 high dimension에서는 과적합의 문제가 발생하는 한계가 있었다. 이를 해결하기 위해 데이터에 맞게 basis function을 바꾸는 것은 어떠할까?</p><p>SVM은 데이터에 맞게 hyperplane을 설정하는 것이므로 맥락에 부합한다. 이는 basis function의 후보 가운데 일부를 선택해서 데이터에 적합시키는 것이므로 ‘차원의 저주’로 부터 좀 더 자유로워질 수 있다. 또한 convex optimization 문제로 풀 수 있기 때문에 solution이 명확하다.</p><p>좀 더 다른 방식으로, basis function 개수는 고정하지만 parameter를 통해 data에 맞는 basis function 자체를 바꾸는 것을 생각할 수 있다. 가장 대표적인 방식이, feed forward neural network(multilayer perceptron)이다. 이 모델은 SVM에 비해 compact하며 학습속도가 빠르다. 그러나 convex optimization 문제가 아니므로 해를 찾기 어려울 수 있다.</p><p>multilayer perceptron에서 결정해야할 parameter는 Maximum likelihood를 사용해서 결정한다.(뒤에서 Jacobian 이나 Hessian을 통해서 error backpropagation의 작동원리를 배울 것임)</p><p><br /></p><h3 id="51-feed-forward-network-functions">5.1 Feed-forward Network Functions</h3><p>chap 3 과 4의 모델은 다음과 같다.</p>\[y(\boldsymbol{x}, \boldsymbol{w}) = f (\sum_{i=1}^M w_j \phi_j (\boldsymbol{x}) )\]<p>multilayer perceptron 모델에서는 non-linear basis fucntion인 $\phi_j (\boldsymbol{x})$ 가 adjustable parameter에 의존하도록 하겠다.( how? layer를 거치면서 $\phi$ 는 input과 weight $\boldsymbol{w}$의 결합으로 만들어짐 )</p><p>[modeling]</p><p>input variable : D개 (i)</p><p>linear combination of input variable : M개 (j)</p><p>superscript : layer</p><p>activation : $a_j$</p><p>differentiable nonlinear <strong>unit</strong> activation function(last layer) : h (data의 특성에 의해 / target의 분포적 특성에 의해 결정됨) (Regression : identity function // binary classification : sigmoid function // Multiclass classification : softmax)</p><p>differentiable nonlinear activation function : sigmoid, tanh, relu …</p><p>hidden unit : z</p>\[a_j = \sum _{i=1} ^D w_{ji} ^{(1)} x_i + w_{j0} ^{(1)} \\ z_j = h(a_j)\]<p>아래 그림은 two layer neural network를 나타내는데, node는 deterministic variable이므로, probabilistic graphical model(chap 8)은 아니다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-1.png" width="70%" height="70%" title="1" alt="relative" /></p><p>식과 그림에서도 알 수 있듯, 각 layer는 perceptron 모델과 매우 유사하다. 결국 perceptron 모델 또한 에러를 줄이는 perceptron parameter w를 결정하고자 한다. 그러나 perceptron 모델은 class를 +1 과 -1 로 나누는 데에서 activation function이 step function인 반면, neural network에서는 differentiable 하다는 것이 차이라 할 수 있다.</p><p>만약 hidden unit이 linear라면 결국 식 (5.7) 와 같이 중첩해서 식을 쓸 필요가 없고, input 과 output만이 있는 매우 simple한 모델을 만들 수 있을 것이다. 이러한 형태는 나중에 12장에서 배울 principal component analysis와 매우 유사하다고 할 수 있다.</p><p>network architecture에서 자주 사용되는 skip-layer connection은 경사소실을 막아, sparse 모델이 특정 gredient에만 영향을 크게 받는 것을 방지한다.</p><p>“모든 input 과 oupter이 hidden layer 에 의해 연결된다면 weight는 어떻게 정할 것인가 =&gt; maximum likelihood and Bayesian apporach “</p><p>아래 그림은 hidden unit과 network 학습 결과를 보여준다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-2.png" width="70%" height="70%" title="1" alt="relative" /></p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-3.png" width="70%" height="70%" title="1" alt="relative" /></p><p><br /></p><h4 id="511-weight-space-symmetries">5.1.1 Weight-space symmetries</h4><p>feed-forward network의 특징 중 하나는, weight vector에 대한 multiple distinct choice 가 결국 같은 mapping function을 만들어 낸다는 것이다.</p><p>ex1 ) tanh function와 같은 기함수의 특징을 활용할 때 M개의 hidden unit에 대해 $2^M$ 개의 weight vector가 동일한 network를 만들어 낼 것이다.</p><p>ex2 ) hidden unit의 순서를 바꾸면 된다.</p><p><br /></p><h3 id="52-network-training">5.2 Network Training</h3><p>polynomial curve fitting(chap 1) 에서는 sum of square error function을 minimize 하는 parameter 값을 추정하는 것을 배웠다. neural network에서도 마찬가지로 parameter를 추정하는 것이 중요하다.</p><p>우선 network output에 대한 확률적 접근을 할 수 있다.</p><p>target $\boldsymbol{t}$ 가 Gaussian distribution을 따른다고 생각해보자. Regression setting에서 unit activation function을 생각하면 parameter에 대한 MLE를 찾을 수 있다. 또한 Gaussian 가정 하에서는 likelihood function을 최대화 하는 것은 sum of square error function을 최소화 하는 것과 같다.</p><p>가우시안의 경우에는 convex 문제를 쉽게 풀 수 있지만, 실제로 많은 경우에는 network function이 non-linearity를 가지고 있고, error function 또한 마찬가지이다. =&gt; analytic 하게 구해야 한다.</p><p>binary classification의 경우는 maximum likelihood 방식으로 parameter를 추정하는 것이 cross entropy error function을 최소화 하는 것과 동일하다. (sum of square error는 학습의 속도 또한 느리며, ML 방식에서 도출할 수 없는 error 이므로 generalization이 어렵다) 또한 target이 특정 분포를 따르는 것이 아니라, 0 또는 1로 명확하게 labelling 되어 있기 때문에 분산을 정의할 필요가 없다.</p><p>binary classification with multiple target의 경우, linear classification은 각 linear model이 output과 각각 linearly independent 하게 영향을 주지만, neural network에서는 각 input이 각 output에 non-linearly 영향을 준다는 것이다.</p><p><br /></p><h4 id="521-parameter-optimization">5.2.1 Parameter optimization</h4><p>geometric apporach</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-4.png" width="70%" height="70%" title="1" alt="relative" /></p><p>weight space에서 $\delta \boldsymbol{w}$ 만큼 움직였을 때, error function의 변화는 $\delta E \simeq \delta \boldsymbol{w}^T \nabla E(\boldsymbol{w}$) 이고 이때 gredient는 error를 가장 많이 줄이는 방향이다. 따라서 gredient가 0에 매우 근사할 때 error를 가장 작게 하는 값에 도달했다고 할 수 있다.</p><p>“Points at which the gradient vanishes are called stationary points and may be further classified into minima, maxima, and saddle point”</p><p>Network 안에는 수많은 inequivalent stationary point 와 inequivalent minima 가 존재한다. 그러나 반드시 global minima를 찾을 필요는 없으며 존재하지 않을 수도 있다. 실제로 할 수 있는 것은 local minima 후보지를 몇개 선정한 다음 이를 비교해서 최적의 값을 찾는 것이다.</p><p>(Newton-Rhapson 방법과 같이 iterative하게 parameter 값을 추정해야할 경우도 있다.)</p><p><br /></p><p><br /></p><h3 id="55-regularization-in-neural-networks">5.5 Regularization in Neural Networks</h3><p>hidden unit의 개수는 모델을 설계할 때 정하는 free parameter이며 모델 자체의 성능을 결정하게 된다. 한 방법으로 maximum likelihood setting을 통해서 최적의 hidden unit 개수를 결정할 수도 있을 것이다. 아래 그림은 hidden unit의 개수에 따른 fitting 결과를 보여준다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-5.png" width="70%" height="70%" title="1" alt="relative" /></p><p>overfitting을 방지하는 방법으로는 초기에 hidden unit의 개수를 매우 큰 모형을 만든 다음 데이터를 적합해가면서 sparse한 모형을 만들어 내는 방식이 있다. 이를 위해 regularized error를 설정하는 것을 생각해볼 수 있다.(weight decay) 또한, 이전에도 배웠지만 L2 regularization 하에서 최적의 계수를 찾는 것은 gaussian prior에서 MAP를 찾는 것과 동일하다.</p>\[\tilde E(\boldsymbol{w}) =E(\boldsymbol{w}) + \frac{\lambda}{2}\boldsymbol{w}^T\boldsymbol{w}\]<p>또다른 방법으로는 validation set을 통해서도 적절한 hidden unit의 개수를 설정할 수 있을 것이다(또한 hidden unit을 만드는 weight를 결정할 수 있을 것이다)</p><p><br /></p><h4 id="551-consistent-gaussian-priors">5.5.1 Consistent Gaussian Priors</h4><p>weight decay의 한계는 neural network mapping에서 weight에 대한 transformation(scaling) 과 일치하지 않는 부분이 있다는 것이다.</p><p>기존 데이터를 transform한 데이터를 생각해보자. 두 데이터를 모델을 통해 train 했을 때, 일반적으로 weight 는 다르겠지만 두 모델의 동일한 layer의 weight는 linear transform으로 서로 표현될 수 있을 것이다. 이때에 regularization을 생각해보자. linear transform에 의해 변형된 데이터이므로, regularization 또한 동일한 데이터(변수)에 적용되어야 할 것이다.</p><p>그러나 위에서 본 regularized error 는 이러한 점을 만족하지 못한다.(layer 별로 activation function이 다르기 때문에 regularization 또한 다르게 적용되어야 한다) 이를 위해 새로운 regularization term을 제시한다. $\mathcal{w}_1$ 은 첫번째 layer, $\mathcal{w}_2$ 는 두번째 layer를 의미한다.</p>\[\frac{\lambda_1}{2}\sum_{w \in \mathcal{w}_1}w^2 + \frac{\lambda_2}{2}\sum_{w \in \mathcal{w}_2}w^2\]<p>weight의 prior를 고려한다면 prior는 다음과 같다.(regularizer can be interpreted as the negative loarithm of prior)</p>\[p(\boldsymbol{w}) \propto exp(- \frac{1}{2} \sum_k \alpha_k ||\boldsymbol{w}||_k^2)\]<p><br /></p><h4 id="552-early-stopping">5.5.2 Early stopping</h4><p>모델의 복잡성을 control하는 방법으로 regularization의 대안으로 early stopping을 제시한다. network training에서는 error는 비증가(non-increasing) 함수이다. 그러나 validation set을 통해 모델 검증을 해보면 training의 횟수가 늘어날수록, 즉 데이터에 과적합이 되는 경우 오히려 error가 커지는 현상을 발견할 수 있다. 즉, 적절한 training 횟수를 위해 early stopping이 필요하다.</p><p>또한 자유도에 대한 내용이 언급되고 있다. 저자는 모델 학습이 진행될수록 네트워크의 degree of freedom이 증가할 것이라 말하고 있다. 모델 초기에는 모든 weight들이 동일하게 가중치를 가지고 있는 상태이나 training 동안 모델이 데이터에 적합되면서 일부 weight은 커지고 또 일부 weight은 작아지기 때문에 df의 값은 상대적으로 training 을 반복하면서 커진다고 할 수 있다.</p><p><br /></p><h4 id="553-invariances">5.5.3 Invariances</h4><p>pattern recognition에서 input의 tranforming에 대해서 결과가 바뀌어서는 안된다. 예를들어 input data의 position을 바꾼다거나, 혹은 사이즈를 바꾼다거나 하는 등의 transforming은 결과값을 다르게 만들어서는 안될 것이다.</p><p>만약 데이터가 매우 많다면 모델의 invariance는 자연스럽게 학습될 것이다. 많은 데이터 안에서는 자연스럽게 여러가지 transforming에 대한 것을 학습할 수 있기 때문이다. 그러나 데이터가 많지 않다면?? 요구되는 invariant 가 매우 많다면??</p><p>이에 대한 대안으로 책에서는 4가지를 제시한다</p><ol><li><p>data augmentation(replication을 batch 각각에 넣어주면 더 좋을 것)</p><li><p>regularization term(transforming을 제한, 뒤에 나오는 tangent propagation)</p><li><p>tranformation과 관련없는 변수를 미리 추출</p><li><p>network 모델 자체에 invariance properties를 만들어 놓음. (local receptive fields, shared weights)</p></ol><p><br /></p><h4 id="554-tangent-propagation">5.5.4 Tangent propagation</h4><p>continuous transformation에 대해서만 고려해보자.(rotation not reflection)</p><p>특정 변환에 의해서 D 차원 input space 에서 M차원의 manifold로 변형될 수 있다. 아래 그림을 보자.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-6.png" width="70%" height="70%" title="1" alt="relative" /></p><p>$\xi$에 의해 transformation이 되고 있고 이러한 변형을 $s(x_n, \xi)$ 라고 할 수 있다. 이때 point $x_n$에서 tangent 값은 아래와 같다.</p>\[\tau_n = \frac {\partial s(x_n, \xi)}{\partial \xi} |_{\xi = 0}\]<p>output에 대한 derivative 는 아래와 같다.</p>\[\frac{\partial y_k}{\partial \xi} | _{\xi=0} = \sum_{i=1}^D \frac{\partial y_k}{\partial x_i} \frac{\partial x_i}{\partial \xi} |_{\xi=0} = \sum_{i=1}^D J_{ki} \tau_i\]<p>이를 활용해서 error function을 변형해보자.</p><p>regularization coefficient $\lambda$와 regularization function $\Omega$ 에 대해서</p>\[\Omega = \frac{1}{2} \sum_n \sum_k ( \frac{\partial y_k}{\partial \xi} | _{\xi=0} )^2\] \[\tilde E = E + \lambda \Omega\]<p>라고 둘 수 있다. 만일 transformation에 대해서 network mapping function이 invariant 하다면 regularization function $\Omega$는 zero가 될 것이다. 또한 $\lambda$ 값은 데이터에 대한 fitting과 invariant property에 대한 학습을 조절해주는 역할을 한다.</p><p>이를 통해 볼때, regularization function은 결국 Jacobian을 통해 weight 에 영향을 받는다. 그러므로 backpropagation 방식과 동일하게 regularizer의 derivative를 구해 적절한 weight을 업데이트한다. 즉 tangent propagation 방식은 앞에서 학습한 regularization과 그 방식이 거의 유사한 것이다.</p><p>비슷한 테크닉으로, tangent distance는 nearest-neighbour classifier와 같은 distance 기반의 분석법에서 invariance property를 찾아낼 수 있다.</p><p><br /></p><h4 id="556-convolutional-networks">5.5.6 Convolutional networks</h4><p>5.5.3에서 나오는 4가지 방법 중 마지막 방법을 설명해보도록 하겠다. 이 단락에서는 network 구조 자체에 invariance properties를 만들고자 한다. 이러한 시도는 이미지 데이터 처리에 사용되는 convolutional neural network의 기반이 되었다.</p><p>미묘한 변화까지도 감지하기 위한 네트워크 구조를 만들기 위해 fully connected network를 만든다고 해도, ‘이미지’ 데이터는 주변 데이터들과 큰 상관관계를 갖는다는 특성이 있다. 그러므로 vision 분야에서는 <em>local feature</em> 를 찾아내려는 시도를 많이하고 있다.(cnn의 핵심 = feature extraction)</p><p>convolutional neural network는 local feature를 찾기 위해 local receptive field // weight sharing // subsampling 이라는 3가지 개념을 제시한다.</p><p>input image는 sharing weight을 통해서 학습이 되고, image의 subregion으로부터 weight와 bias를 통해 unit으로 이뤄진 feature map을 만든다. 여기서 각 unit들은 feature detector의 역할을 한다. 혹여나 이미지가 이동된다고 하더라도, feature map에서의 활성위치(unit) 만 바뀌면 되기 때문에 invariance가 유지된다.</p><p>convolutional unit의 output은 subsampling layer의 input을 만든다. subsampling unit은 feature map의 정보를 보다 압축한다. 따라서 image shift 가 발생하는 경우 이를 보다 민감하게 찾게 된다.(pooling과 유사?)</p><p>이를 정리하면 Convolutional neural network를 다음과 같은 구조로 표현할 수 있다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-7.png" width="70%" height="70%" title="1" alt="relative" /></p><p><br /></p><h4 id="557-soft-weight-sharing">5.5.7 Soft weight sharing</h4><p>모델 복잡도를 통제하는 방법 중 하나로 그룹화를 한 뒤 동일한 weight을 주는 것을 들 수 있다. 이 방법은 translation invariance를 위한 방법 중 하나이기도 하다. 이 방법은 weight에 대한 제약이 선행(그룹 간 weight의 평균, 그룹내 weight의 분산)되어야 하며, soft한 제약을 통해 특정 그룹의 weight가 similar value를 갖도록 한다.</p><p>따라서 이 방식은 결국 mixture model을 고려하는 것과 동일시된다. 확률밀도함수는 다음과 같다</p>\[\begin{align} &amp; p(w_i) = \sum _{j=1} ^ M \pi_j \mathcal{N}(w_i | \mu_j, \sigma_j^2) \\ &amp; p(\boldsymbol{w}) = \prod _i p(w_i) \end{align}\]<p>negative loagrithm(ML을 극대화하는 것과 동일)을 통해 regularization function을 다음과 같이 만들 수 있다.</p>\[\Omega(\boldsymbol{w}) = - \sum_i ln (\sum_{j=1} ^M \pi_j \mathcal{N}(w_i | \mu_j, \sigma_j^2))\]<p>total error function은 아래와 같다.</p>\[\tilde E(\boldsymbol{w}) = E(\boldsymbol{w}) + \lambda \Omega(\boldsymbol{w})\]<p>이와 같이 정의한 error는 weight w와 파라미터인 $\pi, \mu, \sigma$ 에 의해 minimize된다. 그 방법으로는 conjugate-gradients 혹은 quasi-Newton method 같은 것으로 weight를 업데이트하면서 동시에 EM알고리즘을 통해 mixture distribution의 파라미터 값을 업데이트하는 방식이 있다.(공동 최적화를 통한 수치적 안정성)</p><p>total error function에 대한 derivative 를 구하기 위해서 우선 coefficient 인 $\pi$ 에 대한 prior를 $\pi_j$로 먼저 설정한 뒤, posterior를 나타낸다.</p>\[\textrm{posterior} \ \ \gamma_j(w) = \frac {\pi_j \mathcal{N}(w|\mu_j, \sigma_j ^2)}{\sum_k \pi_k \mathcal{N}(w|\mu_k, \sigma_k ^2)}\]<p>이때 total error function에 대한 derivative를 살펴보자. weight에 대한 derivative 는 다음과 같다.</p>\[\frac {\partial \tilde E}{\partial w_i} = \frac {\partial E}{\partial w_i} + \lambda \sum_j \gamma_j(w_i) \frac {(w_i - \mu_j)}{\sigma^2 _j}\]<p>식을 자세히 보면 regularization term은 weight을 $j^{th}$ Gaussian의 중심으로 모으는 역할을 하고 있음을 알 수 있다(표준화)</p><p>비슷하게 $\mu , \sigma $ 에 대해서도 derivative 를 구할 수 있으며, 의미는 비슷하다.(sharing, grouping)</p><p>만일 $\sigma^2 _j = exp(\eta_j)$ 라고 둔다면 분산의 값이 0이 되는 경우를 막을 수 있으므로 유용하다.(9장 mixture model에서 설명)</p><p>mixing coefficient $\pi$에 대한 제약을 위해(합 1) softmax function을 사용할 수 있으며 derivative 를 구하면</p>\[\frac {\partial \tilde E}{\partial \eta_j} = \sum _i \{\pi_j - \gamma_j(w_i) \}\]<p>이므로 $\pi_j$ 는 사후분포의 평균으로 가까워짐을 알 수 있다.</p><p><br /></p><h3 id="56-mixture-density-networks">5.6 Mixture Density Networks</h3><p>supervised learning의 목적은 조건부분포 $p(t | x)$ 를 구하고자 하는 것이다. 그러나 실제 문제들에서 Gaussian을 가정하는 것은 잘못된 결과를 이르게 할 수도 있다.</p><p>causality를 기반으로 한 forward problem은 many to one의 문제로 인과관계에 의한 정확한 결과를 예측할 수 있다. 반면 inverse problem을 생각해보자. 즉 one to many 의 문제를 푸는 것으로, 어떤 현상들이 발생했을 때 이를 바탕으로 특정사건이 일어날 것이라 예측할 수 있을지 단정짓기 어렵다. (명확한 인과관계가 밝혀지지 않는 이상 어떠한 결과를 가져올지 단정짓기 어렵다)</p><p>아래 그림은 forward problem과 inverse problem을 설명한다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-8.png" width="70%" height="70%" title="1" alt="relative" /></p><p>그럼 조건부분포를 찾기위한 일반적인 framework는 없을까?</p><p>이 책에서는 mixture density network를 제시한다. 즉 mixing coefficients 와 component density 모두를 input vector X에 대한 flexible function으로 생각하는 것이다.</p><p>Gaussian components 를 가정한다면 아래와 같은 모델을 만들 수 있다</p>\[p(t|x) = \sum _{k=1} ^K \pi_k(x) \ \mathcal{N}(t|\mu_k(x), \sigma_k ^2 (x))\]<p>이 모델은 input vector에 의해 component의 분산이 영향을 받는 heteroscedastic model(이분산성 모델)이다.</p><p>mixture 모델에서 $\pi_k(x), \mu_k (x), \sigma_k ^2 (x)$ 는 neural network 모델의 output에 영향을 받는다. 즉 mixture model의 parameter를 찾는 데에 hidden unit이 모두 공유된다. 그래서 만약 L개의 mixture component와 output t가 K개의 component를 가진다면 network는 L 개의 output unit activation $a_k ^ {\pi}$ 과 K개의 output $a_k ^ {\sigma}$, L x K 개의 output $a_{kj} ^ {\mu}$ 를 갖게 될 것이다.</p><p>즉 network의 output 수는 (K+2)L 이며 mixture를 고려하지 않을 때에는 K 개의 output 만을 가진다는 데에서 비교된다.</p><p>이때 coefficeint의 조건과, 분산값이 양이 된다는 조건을 만족시키기 위해 softmax output form이나 exponential을 활용하면 error function은 다음과 같다.</p>\[E(w) = - \sum _{n=1} ^N ln \ \{ \sum_{k=1}^k \pi_k(x_n,\boldsymbol{w}) \mathcal{N}(t_n | \mu_k(x_n, \boldsymbol{w}), \sigma_k^2(x_n, \boldsymbol{w}) \}\]<p>derivative 를 구하는 방식은 5.5.7에서와 유사하게 생각할 수 있을 것이며, mixture model이므로 prior를 정의하고 posterior를 도입하도록 한다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 70% 70%'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/prml-5-9.png" width="70%" height="70%" title="1" alt="relative" /></p><p>교재에서 제시하는 toy example을 볼 때, 찾고싶은 조건부분포 $p(t|x)$ 는 그림 (c)에서처럼 multimodal이다.</p><p>mixture model을 통해 $p(t|x)$ 를 구하게 되면 이를 활용한 대표값을 구할 수 있다</p><p>«««&lt; HEAD mixture model을 통해 $p(t|x)$를 구하게 되면 이를 활용한 대표값을 구할 수 있다 =&gt; ======= =&gt;</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>3d43dae3582fdaaa38969b0e32e7f9823bd71906 $E(\boldsymbol{t}|x) , E(||\boldsymbol{t} - E(\boldsymbol{t}|x)||^2|x) $</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>그러나 평균값이 항상 데이터를 잘 나타낸다고 할 수는 없다. 로봇팔 문제를 생각해보면 inverse problem에서 두가지 가능한 해의 평균이 옳은 답이라 말하기는 힘들다. 이를 해결하기 위해서는 가능성이 높은 성분의 평균값을 각각의 x값에 대해 구하는 것이다. 이는 그림 (d)에서 잘 나타난다.</p><p><br /></p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/prml/" class="post-tag no-text-decoration" >PRML</a> <a href="/tags/machine-learning/" class="post-tag no-text-decoration" >Machine learning</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=PRML-5 - For Statistics&url=https://hwankam.github.io/posts/PRML5/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=PRML-5 - For Statistics&u=https://hwankam.github.io/posts/PRML5/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=PRML-5 - For Statistics&url=https://hwankam.github.io/posts/PRML5/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/PRML6/">PRML-6</a><li><a href="/posts/PRML5/">PRML-5</a><li><a href="/posts/PRML4/">PRML-4</a><li><a href="/posts/PRML3/">PRML-3</a><li><a href="/posts/CASI9/">Computer Age Statistical Inference - chap 9</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/datascience/">datascience</a> <a class="post-tag" href="/tags/datamining/">datamining</a> <a class="post-tag" href="/tags/machinelearning/">machinelearning</a> <a class="post-tag" href="/tags/islr/">ISLR</a> <a class="post-tag" href="/tags/statistical-method/">statistical method</a> <a class="post-tag" href="/tags/efron/">Efron</a> <a class="post-tag" href="/tags/prml/">PRML</a> <a class="post-tag" href="/tags/machine-learning/">machine learning</a> <a class="post-tag" href="/tags/machine-learning/">Machine learning</a> <a class="post-tag" href="/tags/categorical-data/">categorical data</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/PRML3/"><div class="card-body"> <span class="timeago small" >Nov 7, 2021<i class="unloaded">2021-11-07T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PRML-3</h3><div class="text-muted small"><p> 3. Linear Models for Regression linear model : parameter에 대한 linear function ( input variables의 nonlinear function이 있다하더라도 이들의 결합이 파라미터 관점에서 선형결합이면 linear model이라 칭한다 ) 이 장에서는 선형모형과 이를 통한 학습 및 예측...</p></div></div></a></div><div class="card"> <a href="/posts/PRML4/"><div class="card-body"> <span class="timeago small" >Jan 19<i class="unloaded">2022-01-19T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PRML-4</h3><div class="text-muted small"><p> 4. Linear Models for Classification 이번 chapter는 “Input space를 K개의 Class로 나누는 것”이 핵심이다. 이때 나눠지는 영역은 decision region, 나누는 boundary를 decision boundary 혹은 decision surface라 한다. 특히 이번 chapter에서 중요한 것은 ...</p></div></div></a></div><div class="card"> <a href="/posts/PRML6/"><div class="card-body"> <span class="timeago small" >Mar 1<i class="unloaded">2022-03-01T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>PRML-6</h3><div class="text-muted small"><p> 6. Kernel Methods [서론] there is a class of pattern recognition techniques ==&gt; training data points are kept, memory based method ex ) nearest neighborhood 방법은 training data와 가장 유사한 label을 te...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/PRML4/" class="btn btn-outline-primary" prompt="Older"><p>PRML-4</p></a> <a href="/posts/PRML6/" class="btn btn-outline-primary" prompt="Newer"><p>PRML-6</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/username">your_full_name</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/datascience/">datascience</a> <a class="post-tag" href="/tags/datamining/">datamining</a> <a class="post-tag" href="/tags/machinelearning/">machinelearning</a> <a class="post-tag" href="/tags/islr/">ISLR</a> <a class="post-tag" href="/tags/statistical-method/">statistical method</a> <a class="post-tag" href="/tags/efron/">Efron</a> <a class="post-tag" href="/tags/prml/">PRML</a> <a class="post-tag" href="/tags/machine-learning/">machine learning</a> <a class="post-tag" href="/tags/machine-learning/">Machine learning</a> <a class="post-tag" href="/tags/categorical-data/">categorical data</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}}); </script> MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) { alert("Math Processing Error: "+message[1]); }); MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) { alert("Math Processing Error: "+message[1]); }); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
